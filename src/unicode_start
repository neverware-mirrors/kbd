#!/bin/sh
# Enables Unicode processing in the current console.
#

if [ ! -e /proc/self/fd/0 ] ; then
   echo "Won't set unicode mode: Can't determine console type;" >&2
   echo " Please ensure that /proc is mounted." >&2
   exit 1
fi

readlink /proc/self/fd/0 | grep -q -e /dev/vc -e '/dev/tty[^p]' -e /dev/console
if [ $? -eq 1 ]; then
    echo  "Won't set unicode mode: not a VT." >&2
    exit 1
fi

# 1. The input side: the keyboard driver.

# Set the keyboard driver in Unicode mode. (Default is ASCII mode.)
# This really does nothing with the way normal keys are handled in
# the kernel. All it does is:
# - It is necessary for `dumpkeys' in order to not drop U+XXXX
#   entries from the keymaps.
# - It is necessary for `loadkeys' in order to avoid warnings.
# - Unicode characters typed as Alt-x1 ... Alt-xn (where x1,...,xn
#   are digits on the numeric keypad) will be emitted in UTF-8.

kbd_mode -u

# Change the keyboard mapping in such a way that the non-ASCII keys
# produce UTF-8 encoded multibyte sequences, instead of single bytes
# >= 0x80 in a legacy 8-bit encoding.

dumpkeys | loadkeys --unicode

# 2. The output side: the console screen.

# Tell the console output driver that the bytes arriving are UTF-8
# encoded multibyte sequences.

printf '\033%%G'

# Tell the graphics card how to display Unicode characters not
# contained in the IBM 437 character set (on PCs). The font should
# have a Unicode map attached, or explicitly specified, e.g.,
# by giving `def.uni' as a second argument.

# Also drdos8x16 is a good candidate.
for DEFAULT_UNICODE_FONT in \
	/usr/share/consolefonts/Uni1-VGA16.psf* \
	/usr/share/consolefonts/LatArCyrHeb-16.psf* \
	/usr/share/consolefonts/default*.psf* \
	/usr/share/consolefonts/*.psf*
do
	if [ -f "$DEFAULT_UNICODE_FONT" ]; then
		break
	fi
done

case $# in
	2)
		setfont $1 -u $2
		;;
	1)
		setfont $1
		;;
	0)
		setfont "$DEFAULT_UNICODE_FONT"
		;;
	*)
		echo "usage: unicode_start [font [unicode map]]"
		;;
esac
